/* autogenerated file, do not edit */
/* clang-format off */
#ifndef CASEMATE_H
#define CASEMATE_H

#ifdef __KVM_NVHE_HYPERVISOR__
#include <linux/stdarg.h>
#include <linux/types.h>
#else
#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>
#endif

/*
 * Casemate public interface
 */

#define CASEMATE_VERSION "2.2.2"

/* auto-included by Makefile */
#ifndef CASEMATE_CONFIG_H
#define CASEMATE_CONFIG_H

//////////////
// Configuration

typedef enum {
	CM_PRINT_NONE = 0,

	CM_PRINT_WHOLE_STATE_ON_STEP = 1,
	CM_PRINT_DIFF_TO_STATE_ON_STEP = 2,
	CM_PRINT_ONLY_UNCLEAN = 4,

	CM_PRINT_ALL = CM_PRINT_WHOLE_STATE_ON_STEP | CM_PRINT_DIFF_TO_STATE_ON_STEP,
	CM_PRINT_ALL_CONDENSED = CM_PRINT_ALL | CM_PRINT_ONLY_UNCLEAN,
} casemate_print_opts_t;

#define CASEMATE_DEFAULT_PRINT_OPTS CM_PRINT_NONE

struct casemate_checker_options {
	/**
	 * @promote_DSB_nsh: Silently promote all DSB NSH to DSB ISH
	 */
	bool promote_DSB_nsh;

	/**
	 * @promote_TLBI_nsh: Silently promote all TLBI to broadcast ones
	 */
	bool promote_TLBI_nsh;

	/**
	 * @promote_TLBI_by_id: Silently promote all TLBI-by-ASID and by-VMID to ALL
	 */
	bool promote_TLBI_by_id;

	/**
	 * @check_synchronisation: check that locks are respected.
	 *
	 * WARNING: disabling is unsafe for online checking.
	 */
	bool check_synchronisation;

	/**
	 * @enable_printing: print out the current state of the
	 * @print_opts: logging to perform.
	 */
	bool enable_printing;
	casemate_print_opts_t print_opts;
};

#define CASEMATE_DEFAULT_CHECK_OPTS \
	(struct casemate_checker_options) \
	{ \
		.promote_DSB_nsh = false, .promote_TLBI_nsh = false, \
		.promote_TLBI_by_id = false, .check_synchronisation = true, \
		.enable_printing = false, .print_opts = CASEMATE_DEFAULT_PRINT_OPTS, \
	}

struct casemate_log_options {
	/**
	 * @log_format_version: Version of the log format
	 */
	uint8_t log_format_version;

	/**
	 * @condensed_format: if true, trace omits the keys in key/value pairs.
	 */
	bool condensed_format;

	/**
	 * @omit_reads: do not trace reads
	 *
	 * NOTE: this does not prevent tracing on catching fire on a read step
	 */
	bool omit_reads;
};

#define CASEMATE_DEFAULT_LOG_OPTS \
	(struct casemate_log_options) \
	{ \
		.log_format_version = 1, .condensed_format = false, .omit_reads = false \
	}

/**
 * struct casemate_options - Global configuration of ghost model behaviour
 *
 * Provides selective enabling/disabling of supported behaviours.
 */
struct casemate_options {
	/**
	 * @enable_tracing: Printing tracepoints
	 */
	bool enable_tracing;

	/**
	 * @enable_checking: Turn on/off runtime model checking
	 */
	bool enable_checking;

	/**
	 * @track_watchpoints: Only print/trace on watched locations.
	 */
	bool track_watchpoints;

	/**
	 * @log_opts: Options for logging
	 */
	struct casemate_log_options log_opts;

	/**
	 * @check_opts: Options for checker
	 */
	struct casemate_checker_options check_opts;

	/**
	 * @enable_safety_checks: Enables non-functional model-internal consistency checks.
	 */
	bool enable_safety_checks;
};

#define CASEMATE_DEFAULT_OPTS \
	(struct casemate_options) \
	{ \
		.enable_tracing = false, .enable_checking = false, .track_watchpoints = false, \
		.log_opts = CASEMATE_DEFAULT_LOG_OPTS, \
		.check_opts = CASEMATE_DEFAULT_CHECK_OPTS, .enable_safety_checks = false, \
	}

enum ghost_sysreg_kind {
	SYSREG_VTTBR,
	SYSREG_TTBR_EL2,
	SYSREG_VTCR_EL2,
	SYSREG_TCR_EL2,
	SYSREG_MAIR_EL2,
};

struct casemate_model_step;
typedef int (*putc_cb)(const char c);
typedef void (*abort_cb)(const char *msg);
typedef uint64_t (*read_physmem_cb)(uint64_t);
typedef uint64_t (*read_sysreg_cb)(enum ghost_sysreg_kind sysreg);
typedef void (*trace_cb)(const char *record);

/**
 * struct ghost_driver - Callbacks for driving the casemate model
 *
 * @putc: callback for printing a single char.
 * @halt: callback for failed assertion.
 * @read_physmem: perform a read of memory.
 * @read_sysreg: callback for reading system registers.
 * @trace: tracepoint callback.
 *
 * Casemate is standalone, but sometimes performs side-effects,
 * which must be handled by the parent kernel.
 *
 */
struct ghost_driver {
	putc_cb putc;
	abort_cb abort;
	read_physmem_cb read_physmem;
	read_sysreg_cb read_sysreg;
	trace_cb trace;
};

#define CASEMATE_DEFAULT_EMPTY_DRIVER \
	(struct ghost_driver) \
	{ \
		.putc = NULL, \
		.halt = NULL, \
		.read_physmem = NULL, \
		.read_sysreg = NULL, \
		.trace = NULL, \
	}

/**
 * casemate_watch_location() - Watch for changes to a particular physical address.
 *
 * Only has an effect when opts()->track_watchpoints is set.
 *
 * Returns -1 on error.
 */
int casemate_watch_location(uint64_t loc);

/**
 * initialise_ghost_driver() - Setup the ghost driver for this instance.
 */
void initialise_ghost_driver(struct ghost_driver *driver);

#endif /* CASEMATE_CONFIG_H */


/* auto-included by Makefile */
/**
 * enum memory_order_t - A custom subset of standard `memory_order`.
 */
enum memory_order_t {
	WMO_plain,
	WMO_release,
};

/// Decoded TLBIs

enum sm_tlbi_op_stage {
	TLBI_OP_STAGE1 = 1,
	TLBI_OP_STAGE2 = 2,
	TLBI_OP_BOTH_STAGES = TLBI_OP_STAGE1 | TLBI_OP_STAGE2,
};

enum sm_tlbi_op_method_kind {
	TLBI_OP_BY_ALL = 0, /* TLBI ALL* only */
	TLBI_OP_BY_INPUT_ADDR = 1, /* by Input-Address */
	TLBI_OP_BY_ADDR_SPACE = 2, /* by ASID/VMID */

	TLBI_OP_BY_VA = TLBI_OP_BY_INPUT_ADDR,
	TLBI_OP_BY_IPA = TLBI_OP_BY_INPUT_ADDR,

	TLBI_OP_BY_VMID = TLBI_OP_BY_ADDR_SPACE,
	TLBI_OP_BY_ASID = TLBI_OP_BY_ADDR_SPACE,
};

enum sm_tlbi_op_regime_kind {
	TLBI_REGIME_EL10 = 1, /* EL1&0 regime */
	TLBI_REGIME_EL2 = 2, /* EL2 regime */
};

/// Encoded TLBIs

enum tlbi_kind {
	TLBI_vmalls12e1,
	TLBI_vmalls12e1is,
	TLBI_vmalle1is,
	TLBI_alle1,
	TLBI_alle1is,
	TLBI_vmalle1,
	TLBI_alle2,
	TLBI_alle2is,
	TLBI_vale2is,
	TLBI_vae2is,
	TLBI_ipas2e1is
};

enum dxb_kind {
	DxB_ish,
	DxB_ishst,
	DxB_nsh,
};

enum barrier_kind {
	BARRIER_DSB,
	BARRIER_ISB
};

enum ghost_hint_kind {
	/**
	 * @GHOST_HINT_SET_ROOT_LOCK - Set the lock owning a pgtable root.
	 */
	GHOST_HINT_SET_ROOT_LOCK,

	/**
	 * @GHOST_HINT_SET_OWNER_ROOT - Set the pgtable root which owns a pte
	 */
	GHOST_HINT_SET_OWNER_ROOT,

	/**
	 * @GHOST_HINT_RELEASE_TABLE - Stop tracking a whole table (and subtables recursively)
	 */
	GHOST_HINT_RELEASE_TABLE,

	/**
	 * @GHOST_HINT_SET_PTE_THREAD_OWNER - Set the a thread to be the owner of a PTE (only for leaves)
	 */
	GHOST_HINT_SET_PTE_THREAD_OWNER,
};

/**
 * Source location info
 */
struct src_loc {
	const char *file;
	const char *func;
	int lineno;
};

/**
 * initialise_casemate_model() - One-shot initialisation of model state.
 * @opts: a reference to an initial configuration to use during setup.
 * @phys: the start physical address of the memory given to pKVM.
 * @size: the size of the region of physical address space given to pKVM.
 * @sm_virt: the start of the virtual address of the memory the ghost model state can live in
 * @sm_size: the space given for the ghost model memory.
 *
 * `phys` and `size` define the region of memory that the model reserves for its own state.
 *
 * Returns -12 (ENOMEM) if `sm_size` is not enough memory, otherwise 0.
 *
 * NOTE: After this the target must manually initialise the already-existing pagetable memory with steps.
 */
int initialise_casemate_model(struct casemate_options *opts, uint64_t phys, uint64_t size,
			      void *sm_virt, uint64_t sm_size);

/**
 * attach_casemate_model() - Attach monitor to a running model state
 * @st: the start of the virtual address of the memory the ghost model state is at
 *
 * Returns -1 if the pointed to state is not properly initialised
 * Returns 0 otherwise
 */
int attach_casemate_model(void *st);

/**
 * casemate_cpu_id() - Return current CPU identifier.
 *
 * Users should implement this if they want to use the helper macros.
 */
extern uint64_t casemate_cpu_id(void);

/// Transition API Steps ///

// Step helpers

#define SRC_LOC \
	(struct src_loc) \
	{ \
		.file = __FILE__, .lineno = __LINE__, .func = __func__ \
	}

#define THREAD_ID casemate_cpu_id()

#define casemate_model_step_write(...) \
	__casemate_model_step_write(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_write(uint64_t tid, struct src_loc src_loc, enum memory_order_t mo,
				 uint64_t phys, uint64_t val);

#define casemate_model_step_read(...) __casemate_model_step_read(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_read(uint64_t tid, struct src_loc src_loc, uint64_t phys,
				uint64_t val);

#define casemate_model_step_dsb(...) __casemate_model_step_dsb(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_dsb(uint64_t tid, struct src_loc src_loc, enum dxb_kind kind);

#define casemate_model_step_isb() __casemate_model_step_isb(THREAD_ID, SRC_LOC)
void __casemate_model_step_isb(uint64_t tid, struct src_loc src_loc);

#define casemate_model_step_tlbi_reg(...) \
	__casemate_model_step_tlbi_reg(THREAD_ID, SRC_LOC, __VA_ARGS__)

void __casemate_model_step_tlbi_reg(uint64_t tid, struct src_loc src_loc, enum tlbi_kind kind,
				    uint64_t value);

#define casemate_model_step_tlbi(...) __casemate_model_step_tlbi(THREAD_ID, SRC_LOC, __VA_ARGS__)
#define casemate_model_step_tlbi_va(TLBI_KIND, ADDR, TTL, ASID) \
	casemate_model_step_tlbi_reg((TLBI_KIND), (ADDR) | ((TTL) << 44ULL) | ((ASID) << 48ULL))

#define casemate_model_step_tlbi_ipa(TLBI_KIND, ADDR, TTL) \
	casemate_model_step_tlbi_reg((TLBI_KIND), (ADDR) | ((TTL) << 44ULL))

void __casemate_model_step_tlbi(uint64_t tid, struct src_loc src_loc, enum tlbi_kind kind);

#define casemate_model_step_msr(...) __casemate_model_step_msr(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_msr(uint64_t tid, struct src_loc src_loc,
			       enum ghost_sysreg_kind sysreg, uint64_t val);

#define casemate_model_step_hint(...) __casemate_model_step_hint(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_hint(uint64_t tid, struct src_loc src_loc, enum ghost_hint_kind kind,
				uint64_t location, uint64_t value);

#define casemate_model_step_init(...) __casemate_model_step_init(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_init(uint64_t tid, struct src_loc src_loc, uint64_t location,
				uint64_t size);

#define casemate_model_step_memset(...) \
	__casemate_model_step_memset(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_memset(uint64_t tid, struct src_loc src_loc, uint64_t location,
				  uint64_t value, uint64_t size);

#define casemate_model_step_lock(...) __casemate_model_step_lock(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_lock(uint64_t tid, struct src_loc src_loc, uint64_t address);

#define casemate_model_step_unlock(...) \
	__casemate_model_step_unlock(THREAD_ID, SRC_LOC, __VA_ARGS__)
void __casemate_model_step_unlock(uint64_t tid, struct src_loc src_loc, uint64_t address);


#endif /* CASEMATE_H */