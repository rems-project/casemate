/* autogenerated file, do not edit */
/* clang-format off */
#ifndef CASEMATE_H
#define CASEMATE_H

#ifdef __KVM_NVHE_HYPERVISOR__
#include <linux/stdarg.h>
#include <linux/types.h>
#else
#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>
#endif

/*
 * Casemate public interface
 */

#define CASEMATE_VERSION "2.0.2"

/* auto-included by Makefile */
/* Types also defined by UoC's pKVM ghost code headers
 * so do not try to include them in the top-level casemate.h if they are already defined
 */

#ifndef __KVM_NVHE_HYPERVISOR__

#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>

typedef unsigned long u64;
typedef signed long s64;
typedef unsigned int u32;
typedef signed int s32;
typedef int u8;
typedef u64 phys_addr_t;

#else

#include <linux/stdarg.h>
#include <linux/types.h>

#endif /* __KVM_NVHE_HYPERVISOR */


/* auto-included by Makefile */
#ifndef CASEMATE_CONFIG_H
#define CASEMATE_CONFIG_H

//////////////
// Configuration

typedef enum {
	CM_PRINT_NONE = 0,

	CM_PRINT_WHOLE_STATE_ON_STEP = 1,
	CM_PRINT_DIFF_TO_STATE_ON_STEP = 2,
	CM_PRINT_ONLY_UNCLEAN = 4,

	CM_PRINT_ALL = CM_PRINT_WHOLE_STATE_ON_STEP | CM_PRINT_DIFF_TO_STATE_ON_STEP,
	CM_PRINT_ALL_CONDENSED = CM_PRINT_ALL | CM_PRINT_ONLY_UNCLEAN,
} casemate_print_opts_t;

#define CASEMATE_DEFAULT_PRINT_OPTS CM_PRINT_NONE

struct casemate_checker_options {
	/**
	 * @promote_DSB_nsh: Silently promote all DSB NSH to DSB ISH
	 */
	bool promote_DSB_nsh;

	/**
	 * @promote_TLBI_nsh: Silently promote all TLBI to broadcast ones
	 */
	bool promote_TLBI_nsh;

	/**
	 * @promote_TLBI_by_id: Silently promote all TLBI-by-ASID and by-VMID to ALL
	 */
	bool promote_TLBI_by_id;

	/**
	 * @check_synchronisation: check that locks are respected.
	 *
	 * WARNING: disabling is unsafe for online checking.
	 */
	bool check_synchronisation;

	/**
	 * @enable_printing: print out the current state of the
	 * @print_opts: logging to perform.
	 */
	bool enable_printing;
	casemate_print_opts_t print_opts;
};

#define CASEMATE_DEFAULT_CHECK_OPTS \
	(struct casemate_checker_options) \
	{ \
		.promote_DSB_nsh = false, .promote_TLBI_nsh = false, \
		.promote_TLBI_by_id = false, .check_synchronisation = true, \
		.enable_printing = false, .print_opts = CASEMATE_DEFAULT_PRINT_OPTS, \
	}

struct casemate_log_options {
	/**
	 * @log_format_version: Version of the log format
	 */
	uint8_t log_format_version;

	/**
	 * @condensed_format: if true, trace omits the keys in key/value pairs.
	 */
	bool condensed_format;
};

#define CASEMATE_DEFAULT_LOG_OPTS \
	(struct casemate_log_options) \
	{ \
		.log_format_version = 1, .condensed_format = false, \
	}

/**
 * struct casemate_options - Global configuration of ghost model behaviour
 *
 * Provides selective enabling/disabling of supported behaviours.
 */
struct casemate_options {
	/**
	 * @enable_tracing: Printing tracepoints
	 */
	bool enable_tracing;

	/**
	 * @enable_checking: Turn on/off runtime model checking
	 */
	bool enable_checking;

	/**
	 * @track_watchpoints: Only print/trace on watched locations.
	 */
	bool track_watchpoints;

	/**
	 * @log_opts: Options for logging
	 */
	struct casemate_log_options log_opts;

	/**
	 * @check_opts: Options for checker
	 */
	struct casemate_checker_options check_opts;

	/**
	 * @enable_safety_checks: Enables non-functional model-internal consistency checks.
	 */
	bool enable_safety_checks;
};

#define CASEMATE_DEFAULT_OPTS \
	(struct casemate_options) \
	{ \
		.enable_tracing = false, .enable_checking = false, .track_watchpoints = false, \
		.log_opts = CASEMATE_DEFAULT_LOG_OPTS, \
		.check_opts = CASEMATE_DEFAULT_CHECK_OPTS, .enable_safety_checks = false, \
	}

enum ghost_sysreg_kind {
	SYSREG_VTTBR,
	SYSREG_TTBR_EL2,
	SYSREG_VTCR_EL2,
	SYSREG_TCR_EL2,
	SYSREG_MAIR_EL2,
};

struct casemate_model_step;
typedef int (*vprintf_cb)(void* arg, const char *format, va_list ap);
typedef void* (*sprint_make_buf_cb)(char* arg, uint64_t n);
typedef void (*sprint_free_buf_cb)(void *buf);
typedef void (*abort_cb)(const char *msg);
typedef uint64_t (*read_physmem_cb)(uint64_t);
typedef uint64_t (*read_sysreg_cb)(enum ghost_sysreg_kind sysreg);
typedef void (*trace_cb)(const char *record);

/**
 * struct ghost_driver - Callbacks for driving the casemate model
 *
 * @print: callback for printing, with printf-like arguments.
 * @sprint_create_buffer: callback for making a buffer to pass to driver->print().
 * @sprint_destroy_buffer: frees a buffer created with `sprint_create_buffer`.
 * @halt: callback for failed assertion.
 * @read_physmem: perform a read of memory.
 * @read_sysreg: callback for reading system registers.
 * @trace: tracepoint callback.
 *
 * Casemate is standalone, but sometimes performs side-effects,
 * which must be handled by the parent kernel.
 *
 */
struct ghost_driver {
	vprintf_cb print;
	sprint_make_buf_cb sprint_create_buffer;
	sprint_free_buf_cb sprint_destroy_buffer;
	abort_cb abort;
	read_physmem_cb read_physmem;
	read_sysreg_cb read_sysreg;
	trace_cb trace;
};

#define CASEMATE_DEFAULT_EMPTY_DRIVER \
	(struct ghost_driver) \
	{ \
		.print = NULL, .sprint_create_buffer = NULL, .halt = NULL, .read_physmem = NULL, \
		.read_sysreg = NULL, .trace = NULL, \
	}

/**
 * casemate_watch_location() - Watch for changes to a particular physical address.
 *
 * Only has an effect when opts()->track_watchpoints is set.
 *
 * Returns -1 on error.
 */
int casemate_watch_location(uint64_t loc);

/**
 * initialise_ghost_cm_driver() - Setup the global ghost driver.
 */
void initialise_ghost_driver(struct ghost_driver *driver);

#endif /* CASEMATE_CONFIG_H */

/* auto-included by Makefile */
/**
 * enum memory_order_t - A custom subset of standard `memory_order`.
 */
enum memory_order_t {
	WMO_plain,
	WMO_release,
};

/// Decoded TLBIs

enum sm_tlbi_op_stage {
	TLBI_OP_STAGE1 = 1,
	TLBI_OP_STAGE2 = 2,
	TLBI_OP_BOTH_STAGES = TLBI_OP_STAGE1 | TLBI_OP_STAGE2,
};

enum sm_tlbi_op_method_kind {
	TLBI_OP_BY_ALL = 0, /* TLBI ALL* only */
	TLBI_OP_BY_INPUT_ADDR = 1, /* by Input-Address */
	TLBI_OP_BY_ADDR_SPACE = 2, /* by ASID/VMID */

	TLBI_OP_BY_VA = TLBI_OP_BY_INPUT_ADDR,
	TLBI_OP_BY_IPA = TLBI_OP_BY_INPUT_ADDR,

	TLBI_OP_BY_VMID = TLBI_OP_BY_ADDR_SPACE,
	TLBI_OP_BY_ASID = TLBI_OP_BY_ADDR_SPACE,
};

enum sm_tlbi_op_regime_kind {
	TLBI_REGIME_EL10 = 1, /* EL1&0 regime */
	TLBI_REGIME_EL2 = 2, /* EL2 regime */
};

/**
 * struct sm_tlbi_op_method - Decoded TLBI by-method
 * @kind: whether this is "all", by address, or by address-space-identifier.
 */
struct sm_tlbi_op_method {
	enum sm_tlbi_op_method_kind kind;
	union {
		struct tlbi_op_method_by_address_data {
			uint64_t page;

			bool has_level_hint;
			uint8_t level_hint;

			bool has_asid;
			uint8_t asid;

			bool affects_last_level_only;
		} by_address_data;

		struct tlbi_op_method_by_address_space_id_data {
			uint64_t asid_or_vmid;
		} by_id_data;
	};
};

/**
 * struct sm_tlbi_op - A decoded TLB maintenance operation.
 * @stage: whether this affects cached stage1 translations, cached stage2 translations, or both.
 * @regime: the translation regime that this TLB maintenance operation would affect the cached entries of.
 * @method: whether this TLBI is by IPA, by VA, or by VMID, etc., and the relevant address/vmid, etc.
 * @shootdown: whether this TLB maintenance operation is broadcast to other cores.
 */
struct sm_tlbi_op {
	enum sm_tlbi_op_stage stage;
	enum sm_tlbi_op_regime_kind regime;
	struct sm_tlbi_op_method method;
	bool shootdown;
};

/// Encoded TLBIs

enum tlbi_kind {
	TLBI_vmalls12e1,
	TLBI_vmalls12e1is,
	TLBI_vmalle1is,
	TLBI_alle1is,
	TLBI_vmalle1,
	TLBI_vale2is,
	TLBI_vae2is,
	TLBI_ipas2e1is
};

enum dxb_kind {
	DxB_ish,
	DxB_ishst,
	DxB_nsh,
};

enum barrier_kind {
	BARRIER_DSB,
	BARRIER_ISB
};

enum casemate_model_step_kind {
	/**
	 * @TRANS_HW_STEP - Hardware instruction
	 */
	TRANS_HW_STEP,

	/**
	 * @TRANS_ABS_STEP - An abstract software state transition
	 * These generally transition some abstract reified ghost state in the model
	 * e.g. for locks and C initialisations that are not exposed to the model
	 */
	TRANS_ABS_STEP,

	/**
	 * @TRANS_HINT - A non-hardware-model transition
	 * These generally provide additional information to the casemate model,
	 * such as ownership, to resolve otherwise unbounded non-determinism
	 *
	 * Removing HINTs should not change soundness
	 */
	TRANS_HINT,
};

enum ghost_hw_step_kind {
	HW_MEM_WRITE,
	HW_MEM_READ,
	HW_BARRIER,
	HW_TLBI,
	HW_MSR,
};

struct ghost_hw_step {
	enum ghost_hw_step_kind kind;
	union {
		struct trans_write_data {
			enum memory_order_t mo;
			uint64_t phys_addr;
			uint64_t val;
		} write_data;

		struct trans_read_data {
			uint64_t phys_addr;
			uint64_t val;
		} read_data;

		struct trans_barrier_data {
			enum barrier_kind kind;
			enum dxb_kind dxb_data;
		} barrier_data;

		struct trans_tlbi_data {
			enum tlbi_kind tlbi_kind;
			uint64_t value;
		} tlbi_data;

		struct trans_msr_data {
			enum ghost_sysreg_kind sysreg;
			uint64_t val;
		} msr_data;
	};
};

enum ghost_abs_kind {
	/**
	 * @GHOST_ABS_LOCK - Acquire a mutex
	 */
	GHOST_ABS_LOCK,

	/**
	 * @GHOST_ABS_UNLOCK - Release a mutex
	 */
	GHOST_ABS_UNLOCK,

	/**
	 * @GHOST_ABS_INIT - Zeroed initialisation of some fresh memory
	 */
	GHOST_ABS_INIT,

	/**
	 * @GHOST_ABS_MEMSET - A C memset() call.
	 */
	GHOST_ABS_MEMSET,
};

struct ghost_abs_step {
	enum ghost_abs_kind kind;
	union {
		struct trans_init_data {
			uint64_t location;
			uint64_t size;
		} init_data;

		struct trans_lock_data {
			uint64_t address;
		} lock_data;

		struct trans_memset_data {
			uint64_t address;
			uint64_t size;
			uint64_t value;
		} memset_data;
	};
};

enum ghost_hint_kind {
	/**
	 * @GHOST_HINT_SET_ROOT_LOCK - Set the lock owning a pgtable root.
	 */
	GHOST_HINT_SET_ROOT_LOCK,

	/**
	 * @GHOST_HINT_SET_OWNER_ROOT - Set the pgtable root which owns a pte
	 */
	GHOST_HINT_SET_OWNER_ROOT,

	/**
	 * @GHOST_HINT_RELEASE_TABLE - Stop tracking a whole table (and subtables recursively)
	 */
	GHOST_HINT_RELEASE_TABLE,

	/**
	 * @GHOST_HINT_SET_PTE_THREAD_OWNER - Set the a thread to be the owner of a PTE (only for leaves)
	 */
	GHOST_HINT_SET_PTE_THREAD_OWNER,
};

struct ghost_hint_step {
	enum ghost_hint_kind kind;
	uint64_t location;
	uint64_t value;
};

/**
 * Source location info
 */
struct src_loc {
	const char *file;
	const char *func;
	int lineno;
};

struct casemate_model_step {
	/**
	 * @tid: thread identifier.
	 */
	uint8_t tid;

	/**
	 * @seq_id: sequence id number of the transition.
	 */
	uint64_t seq_id;

	/**
	 * @src_loc: string location (path, function name, lineno etc)
	 *           of where the transition happens in the source code.
	 *           For debugging/pretty printing.
	 */
	struct src_loc src_loc;

	enum casemate_model_step_kind kind;
	union {
		struct ghost_hw_step hw_step;
		struct ghost_abs_step abs_step;
		struct ghost_hint_step hint_step;
	};
};

/**
 * initialise_casemate_model() - One-shot initialisation of model state.
 * @opts: a reference to an initial configuration to use during setup.
 * @phys: the start physical address of the memory given to pKVM.
 * @size: the size of the region of physical address space given to pKVM.
 * @sm_virt: the start of the virtual address of the memory the ghost model state can live in
 * @sm_size: the space given for the ghost model memory.
 *
 * `phys` and `size` define the region of memory that the model reserves for its own state.
 *
 * Returns -12 (ENOMEM) if `sm_size` is not enough memory, otherwise 0.
 *
 * NOTE: After this the target must manually initialise the already-existing pagetable memory with steps.
 */
int initialise_casemate_model(struct casemate_options *opts, uint64_t phys, uint64_t size, void *sm_virt, uint64_t sm_size);

/**
 * casemate_model_step() - Take a step in the ghost model.
 */
void casemate_model_step(struct casemate_model_step trans);


/* auto-included by Makefile */
//////////////
// Step helpers

#define SRC_LOC \
	(struct src_loc) \
	{ \
		.file = __FILE__, .lineno = __LINE__, .func = __func__ \
	}

/**
 * casemate_cpu_id() - Return current CPU identifier.
 *
 * Users should implement this if they want to use the helper macros.
 */
extern uint64_t casemate_cpu_id(void);
#define THREAD_ID casemate_cpu_id()

#define casemate_model_step_write(...) __casemate_model_step_write(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_write(uint64_t tid, struct src_loc src_loc, enum memory_order_t mo, uint64_t phys, uint64_t val)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_MEM_WRITE,
				.write_data =
					(struct trans_write_data){
						.mo = mo,
						.phys_addr = phys,
						.val = val,
					},
			},
	});
}

#define casemate_model_step_read(...) __casemate_model_step_read(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_read(uint64_t tid, struct src_loc src_loc, uint64_t phys, uint64_t val)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_MEM_READ,
				.read_data =
					(struct trans_read_data){
						.phys_addr = phys,
						.val = val,
					},
			},
	});
}

#define casemate_model_step_dsb(...) __casemate_model_step_dsb(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_dsb(uint64_t tid, struct src_loc src_loc, enum dxb_kind kind)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_BARRIER,
				.barrier_data =
					(struct trans_barrier_data){
						.kind = BARRIER_DSB,
						.dxb_data = kind,
					},
			},
	});
}

#define casemate_model_step_isb() __casemate_model_step_isb(THREAD_ID, SRC_LOC)
static inline void __casemate_model_step_isb(uint64_t tid, struct src_loc src_loc)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_BARRIER,
				.barrier_data =
					(struct trans_barrier_data){
						.kind = BARRIER_ISB,
					},
			},
	});
}

#define casemate_model_step_tlbi_reg(...) __casemate_model_step_tlbi_reg(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_tlbi_reg(uint64_t tid, struct src_loc src_loc, enum tlbi_kind kind, uint64_t value)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_TLBI,
				.tlbi_data =
					(struct trans_tlbi_data){
						.tlbi_kind = kind,
						.value = value,
					},
			},
	});
}

#define casemate_model_step_tlbi(...) __casemate_model_step_tlbi(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_tlbi(uint64_t tid, struct src_loc src_loc, enum tlbi_kind kind)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_TLBI,
				.tlbi_data =
					(struct trans_tlbi_data){
						.tlbi_kind = kind,
					},
			},
	});
}

#define casemate_model_step_tlbi_va(TLBI_KIND, ADDR, TTL, ASID) \
	casemate_model_step_tlbi_reg((TLBI_KIND), (ADDR) | ((TTL) << 44ULL) | ((ASID) << 48ULL))

#define casemate_model_step_tlbi_ipa(TLBI_KIND, ADDR, TTL) \
	casemate_model_step_tlbi_reg((TLBI_KIND), (ADDR) | ((TTL) << 44ULL))

#define casemate_model_step_msr(...) __casemate_model_step_msr(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_msr(uint64_t tid, struct src_loc src_loc, enum ghost_sysreg_kind sysreg, uint64_t val)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HW_STEP,
		.hw_step =
			(struct ghost_hw_step){
				.kind = HW_MSR,
				.msr_data =
					(struct trans_msr_data){
						.sysreg = sysreg,
						.val = val,
					},
			},
	});
}

#define casemate_model_step_hint(...) __casemate_model_step_hint(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_hint(uint64_t tid, struct src_loc src_loc, enum ghost_hint_kind kind, uint64_t location, uint64_t value)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_HINT,
		.hint_step =
			(struct ghost_hint_step){
				.kind = kind,
				.location = location,
				.value = value,
			},
	});
}

#define casemate_model_step_init(...) __casemate_model_step_init(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_init(uint64_t tid, struct src_loc src_loc, uint64_t location, uint64_t size)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_ABS_STEP,
		.abs_step =
			(struct ghost_abs_step){
				.kind = GHOST_ABS_INIT,
				.init_data =
					(struct trans_init_data){
						.location = location,
						.size = size,
					},
			},
	});
}

#define casemate_model_step_memset(...) __casemate_model_step_memset(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_memset(uint64_t tid, struct src_loc src_loc, uint64_t location, uint64_t value, uint64_t size)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_ABS_STEP,
		.abs_step =
			(struct ghost_abs_step){
				.kind = GHOST_ABS_MEMSET,
				.memset_data =
					(struct trans_memset_data){
						.address = location,
						.size = size,
						.value = value,
					},
			},
	});
}

#define casemate_model_step_lock(...) __casemate_model_step_lock(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_lock(uint64_t tid, struct src_loc src_loc, uint64_t address)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_ABS_STEP,
		.abs_step =
			(struct ghost_abs_step){
				.kind = GHOST_ABS_LOCK,
				.lock_data =
					(struct trans_lock_data){
						.address = address,
					},
			},
	});
}

#define casemate_model_step_unlock(...) __casemate_model_step_unlock(THREAD_ID, SRC_LOC, __VA_ARGS__)
static inline void __casemate_model_step_unlock(uint64_t tid, struct src_loc src_loc, uint64_t address)
{
	casemate_model_step((struct casemate_model_step){
		.tid = tid,
		.src_loc = src_loc,
		.kind = TRANS_ABS_STEP,
		.abs_step =
			(struct ghost_abs_step){
				.kind = GHOST_ABS_UNLOCK,
				.lock_data =
					(struct trans_lock_data){
						.address = address,
					},
			},
	});
}


#endif /* CASEMATE_H */